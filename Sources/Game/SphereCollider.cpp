#include "SphereCollider.h"
#include <Framework\DirectX11.h>
#include "Transform.h"


std::unique_ptr<DirectX::GeometricPrimitive> SphereCollider::m_debugSphere = nullptr;


/// <summary>
/// コンストラクタ
/// </summary>
/// <param name="pTransform">姿勢クラスへのポインタ</param>
/// <param name="radius">半径</param>
/// <param name="offset">座標のオフセット</param>
SphereCollider::SphereCollider(const Transform* pTransform, float radius, const DirectX::SimpleMath::Vector3& offset) 
	: m_pTransform(pTransform)
	, m_radius(radius)
	, m_offset(offset) {
}

/// <summary>
/// 衝突判定
/// </summary>
/// <param name="other">他オブジェクトの当たり判定</param>
/// <returns>
/// true : 衝突している
/// fase : 衝突していない
/// </returns>
bool SphereCollider::Collision(const SphereCollider* other) const {
	auto& rot = m_pTransform->GetRotation();
	auto offset = DirectX::SimpleMath::Vector3::Transform(m_offset,
		DirectX::SimpleMath::Matrix::CreateFromYawPitchRoll(rot.y, rot.z, rot.z));
	auto& rot2 = other->m_pTransform->GetRotation();
	auto offset2 = DirectX::SimpleMath::Vector3::Transform(other->m_offset,
		DirectX::SimpleMath::Matrix::CreateFromYawPitchRoll(rot2.y, rot2.z, rot2.z));
	DirectX::SimpleMath::Vector3 d = (m_pTransform->GetPosition() + offset) - (other->m_pTransform->GetPosition() + offset2);
	float dist2 = d.x*d.x + d.y*d.y + d.z*d.z;
	return dist2 <= (m_radius + other->m_radius)*(m_radius + other->m_radius);
}

/// <summary>
/// 当たり判定の表示
/// </summary>
/// <param name="view">ビュー行列</param>
/// <param name="proj">射影行列</param>
/// <param name="color">色</param>
void SphereCollider::Render(const DirectX::SimpleMath::Matrix& view, const DirectX::SimpleMath::Matrix& proj,
	const DirectX::SimpleMath::Vector4& color) const {
	// 実体がない場合は生成する
	if (!m_debugSphere) {
		m_debugSphere = DirectX::GeometricPrimitive::CreateSphere(DirectX11::Get().GetContext().Get());
	}
	auto matrix = DirectX::SimpleMath::Matrix::CreateScale(m_radius);
	auto& rot = m_pTransform->GetRotation();
	matrix *= DirectX::SimpleMath::Matrix::CreateTranslation(m_offset);
	matrix *= DirectX::SimpleMath::Matrix::CreateFromYawPitchRoll(rot.y, rot.x, rot.z);
	matrix *= DirectX::SimpleMath::Matrix::CreateTranslation(m_pTransform->GetPosition());
	m_debugSphere->Draw(matrix, view, proj, color, nullptr, true);
}

/// <summary>
/// 姿勢クラスへのポインタを取得する
/// </summary>
/// <returns>
/// 姿勢クラスへのポインタ
/// </returns>
const Transform* SphereCollider::GetTransform() const {
	return m_pTransform;
}

/// <summary>
/// 姿勢クラスへのポインタを設定する
/// </summary>
/// <param name="pTransform">姿勢クラスへのポインタ</param>
void SphereCollider::SetTransform(const Transform* pTransform) {
	m_pTransform = pTransform;
}

/// <summary>
/// 半径を取得する
/// </summary>
/// <returns>
/// 半径
/// </returns>
float SphereCollider::GetRadius() const {
	return m_radius;
}

/// <summary>
/// 半径を設定する
/// </summary>
/// <param name="radius">半径</param>
void SphereCollider::SetRadius(float radius) {
	m_radius = radius;
}

/// <summary>
/// オフセットを取得する
/// </summary>
/// <returns>
/// オフセット
/// </returns>
const DirectX::SimpleMath::Vector3& SphereCollider::GetOffset() const {
	return m_offset;
}

/// <summary>
/// オフセットを設定する
/// </summary>
/// <param name="offset">オフセット</param>
void SphereCollider::SetOffset(const DirectX::SimpleMath::Vector3& offset) {
	m_offset = offset;
}
